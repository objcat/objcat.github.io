# 🍎 编译原理

由于不学这个很多东西都不理解, 而我自己又是一知半解, 所以只能做一些一知半解的讲解, 有错误请指出

# 🍎 Unity原生编译

我们`Unity`原生编译是什么样子呢, 我首先要说`Unity`的编译是自动的, 当你打开项目的时候, 或者代码改动的时候, 或者某一个合适的时候, `Unity`会重新把代码编译成`dll`, 这些`dll`在运行游戏和打包的时候可以直接使用, 而`Unity`原生编译出的`dll`一共就两个`Assembly-CSharp.dll`和`Assembly-CSharp-Editor.dll`

## 🌲 Assembly-CSharp.dll

### 🌸 编译路径

首先我们要知道`dll`编译到哪个路径, `test-unity3d`是我的项目文件夹

```
test-unity3d\Library\ScriptAssemblies
```

### 🌸 创建脚本

我们在空工程中创建一个`C#`脚本

![](images/Pasted%20image%2020250824093143.png)

### 🌸 编译

`Unity`在适当的时候会检测, 当存在脚本的时候, 就会编译出来一个`dll`, 叫做`Assembly-CSharp.dll`, 下面的`pdb`文件是调试文件

![](images/Pasted%20image%2020250824094421.png)

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    public GameObject GameObject;
    public Vector3 Transform;
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.position = Transform;
    }
}
```

所以我们知道了这个`dll`是动态生成的, 无论我们删除多少次, 只要源码在它都会编译成`dll`

![](images/Pasted%20image%2020250824095112.png)

我们使用反编译也可以看到这个`dll`包含的内容

## 🌲 Assembly-CSharp-Editor.dll

这个`dll`我们可能并不是很熟悉, 因为初学者一般情况下都不会用到这个, 它是`Editor 扩展脚本`

### 🌸 创建脚本

我们想要编译这个就需要在`Assets`下面创建一个`Edit`文件夹, 然后新建一个脚本叫做`HelloEditor.cs`

![](images/Pasted%20image%2020250824100857.png)

```cs
using UnityEditor;
using UnityEngine;

public class HelloEditor
{
    [MenuItem("Tools/Say Hello")]
    public static void SayHello()
    {
        Debug.Log("Hello from Assembly-CSharp-Editor.dll!");
    }
}
```

### 🌸 编译脚本

写完代码后保存`Unity`就会自动去编译了, 编译完成我们发现多出了一个`Tools`

![](images/Pasted%20image%2020250824100926.png)

里面确实有一个`Say Hello`按钮

我们去编译目录可以看到这个`dll`已经生成了

![](images/Pasted%20image%2020250824100448.png)






