# 🍎 编译原理

由于不学这个很多东西都不理解, 而我自己又是一知半解, 所以只能做一些一知半解的讲解, 有错误请指出

# 🍎 Unity原生编译

我们`Unity`原生编译是什么样子呢, 我首先要说`Unity`的编译是自动的, 当你打开项目的时候, 或者代码改动的时候, 或者某一个合适的时候, `Unity`会重新把代码编译成`dll`, 这些`dll`在运行游戏和打包的时候可以直接使用, 而`Unity`原生编译出的`dll`一共就两个`Assembly-CSharp.dll`和`Assembly-CSharp-Editor.dll`

## 🌲 Assembly-CSharp.dll

### 🌸 编译路径

首先我们要知道`dll`编译到哪个路径, `test-unity3d`是我的项目文件夹

```
test-unity3d\Library\ScriptAssemblies
```

### 🌸 创建脚本

我们在空工程中创建一个`C#`脚本

![](images/Pasted%20image%2020250824093143.png)

### 🌸 编译

在上面提到过`Unity`在脚本改动后就会编译, 我们写在`Assets下面的脚本(不包括Editor文件夹)`脚本都会打包到一个叫做`Assembly-CSharp.dll`, 下面的`pdb`文件是`调试符号文件`, 它保存了`源码信息(行号, 文件路径, 变量名)`, 主要是给IDE提供信息的, 让我们开发的时候更加方便

![](images/Pasted%20image%2020250824094421.png)

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    public GameObject GameObject;
    public Vector3 Transform;
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.position = Transform;
    }
}
```

所以我们知道了这个`dll`是动态生成的, 无论我们删除多少次, 只要源码修改了它都会编译成`dll`

![](images/Pasted%20image%2020250824095112.png)

我们使用反编译也可以看到这个`dll`包含的内容

## 🌲 Assembly-CSharp-Editor.dll

这个`dll`我们可能并不是很熟悉, 因为初学者一般情况下都不会用到这个, 它是`Editor 扩展脚本`

### 🌸 创建脚本

我们想要编译这个就需要在`Assets`下面创建一个`Edit`文件夹, 然后新建一个脚本叫做`HelloEditor.cs`

![](images/Pasted%20image%2020250824100857.png)

```cs
using UnityEditor;
using UnityEngine;

public class HelloEditor
{
    [MenuItem("Tools/Say Hello")]
    public static void SayHello()
    {
        Debug.Log("Hello from Assembly-CSharp-Editor.dll!");
    }
}
```

### 🌸 编译脚本

写完代码后保存`Unity`就会自动去编译了, 编译完成我们发现多出了一个`Tools`

![](images/Pasted%20image%2020250824100926.png)

里面确实有一个`Say Hello`按钮

我们去编译目录可以看到这个`dll`已经生成了

![](images/Pasted%20image%2020250824100448.png)

# 🍎 ET编译原理

我们了解了原生的编译, 再来看看ET的编译, 它主要做了下面三件事

- 拆分模块 → 每个模块独立`dll`使用`asmdef`来区分模块
- 动态加载热更`dll` → 支持热更新
- 减少全量编译 → 提高效率

## 🌲 asmdef

我们先了解一下什么是`asmdef`, 它的全称是`Assembly Definition File`, 是`Unity`提供的机制, 可以人为地拆分程序集, 在项目中的体现是我们可以在ET框架的各个`程序集`中看到这个文件

![](images/Pasted%20image%2020250824102007.png)

我们看看`Unity.Loader`程序集中的代码, 可以看到它就是一个`json`格式

```json
{
    "name": "Unity.Loader",
    "rootNamespace": "ET",
    "references": [
        "Unity.ThirdParty",
        "Unity.Core",
        "HybridCLR.Runtime",
        "MemoryPack",
        "YooAsset",
        "YooAsset.Editor"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [
        ""
    ],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
```

- `references`就是我们这个程序集的依赖关系, 也就是它可以访问谁, 比如`Loader`是可以访问`Unity.Core`的

## 🌲 编译

我们随便打开一个`ET8.1`的项目, 修改一个代码让它去编译

```
test-et81\Unity\Library\ScriptAssemblies
```

可以看到在这个目录下有它编译的`dll`

```
Unity.Core.dll
Unity.Loader.dll
Unity.Editor.dll
Unity.Hotfix.dll
Unity.HotfixView.dll
Unity.Model.dll
Unity.ModelView.dll
Unity.ThirdParty.dll
```

我们可以看到`dll`的命名就是`asmdef`中对应的`name`

## 🌲 动态加载

动态加载的代码存在于

```
test-et81\Unity\Assets\Scripts\Loader\MonoBehaviour\Init.cs
```

我们看一下代码, 关于动态加载`dll`的代码是这个

```cs
CodeLoader codeLoader = World.Instance.AddSingleton<CodeLoader>();
await codeLoader.DownloadAsync();
codeLoader.Start();
```

首先我们创建了一个`CodeLoader`单例, 扔在了`World`单例管理器中, 然后我们调用了`codeLoader.Start`代码来加载`dll`以便游戏能运行起来

```cs
public void Start()
{
    if (!Define.IsEditor)
    {
        byte[] modelAssBytes = this.dlls["Unity.Model.dll"].bytes;
        byte[] modelPdbBytes = this.dlls["Unity.Model.pdb"].bytes;
        byte[] modelViewAssBytes = this.dlls["Unity.ModelView.dll"].bytes;
        byte[] modelViewPdbBytes = this.dlls["Unity.ModelView.pdb"].bytes;
        // 如果需要测试，可替换成下面注释的代码直接加载Assets/Bundles/Code/Unity.Model.dll.bytes，但真正打包时必须使用上面的代码
        //modelAssBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.Model.dll.bytes"));
        //modelPdbBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.Model.pdb.bytes"));
        //modelViewAssBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.ModelView.dll.bytes"));
        //modelViewPdbBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.ModelView.pdb.bytes"));

        if (Define.EnableIL2CPP)
        {
            foreach (var kv in this.aotDlls)
            {
                TextAsset textAsset = kv.Value;
                RuntimeApi.LoadMetadataForAOTAssembly(textAsset.bytes, HomologousImageMode.SuperSet);
            }
        }
        this.modelAssembly = Assembly.Load(modelAssBytes, modelPdbBytes);
        this.modelViewAssembly = Assembly.Load(modelViewAssBytes, modelViewPdbBytes);
    }
    else
    {
        if (this.enableDll)
        {
            byte[] modelAssBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.Model.dll.bytes"));
            byte[] modelPdbBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.Model.pdb.bytes"));
            byte[] modelViewAssBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.ModelView.dll.bytes"));
            byte[] modelViewPdbBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.ModelView.pdb.bytes"));
            this.modelAssembly = Assembly.Load(modelAssBytes, modelPdbBytes);
            this.modelViewAssembly = Assembly.Load(modelViewAssBytes, modelViewPdbBytes);
        }
        else
        {
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly ass in assemblies)
            {
                string name = ass.GetName().Name;
                if (name == "Unity.Model")
                {
                    this.modelAssembly = ass;
                }
                else if (name == "Unity.ModelView")
                {
                    this.modelViewAssembly = ass;
                }

                if (this.modelAssembly != null && this.modelViewAssembly != null)
                {
                    break;
                }
            }
        }
    }
    
    (Assembly hotfixAssembly, Assembly hotfixViewAssembly) = this.LoadHotfix();

    World.Instance.AddSingleton<CodeTypes, Assembly[]>(new[]
    {
        typeof (World).Assembly, typeof (Init).Assembly, this.modelAssembly, this.modelViewAssembly, hotfixAssembly,
        hotfixViewAssembly
    });

    IStaticMethod start = new StaticMethod(this.modelAssembly, "ET.Entry", "Start");
    start.Run();
}
```

我们可以看到程序中大量用到了加载`dll`, 「dll」全称`Dynamic Link Library`, 是编译好的二进制文件, 我们可以通过官方提供的反射来使用里面的类和方法, 你可以把它理解成`java`的`jar`包

```cs
// 如果不是编辑模式就走这里
// enableDll用来判断是否开启动态加载dll, 在项目中的GlobalConfig可以配置, 一般是true
if (this.enableDll)
{
    // 加载本地的dll, 注意这个不是Library中生成的dll, 而是项目目录中的
    // 我们可以看到目录是 public const string CodeDir = "Assets/Bundles/Code";
    // 这就是程序的核心了, 我们可以在「运行时」动态加载dll
    byte[] modelAssBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.Model.dll.bytes"));
    byte[] modelPdbBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.Model.pdb.bytes"));
    byte[] modelViewAssBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.ModelView.dll.bytes"));
    byte[] modelViewPdbBytes = File.ReadAllBytes(Path.Combine(Define.CodeDir, "Unity.ModelView.pdb.bytes"));
    // 加载这些dll库, 通过反射可以使用里面的代码
    this.modelAssembly = Assembly.Load(modelAssBytes, modelPdbBytes);
    this.modelViewAssembly = Assembly.Load(modelViewAssBytes, modelViewPdbBytes);
}
```

这个代码很关键, 用来加载我们工程目录中的`Code`文件夹下的代码, 如果你在运行游戏的时候, `Code`文件夹下没有代码, 那就会报错

```shell
System.IO.FileNotFoundException: Could not find file "D:\project\unity\test-et81\Unity\Assets\Bundles\Code\Unity.Model.dll.bytes"
......
```

是不是很熟悉这个错误呢, 就是因为`loader`没有加载到, 解决方法就是`F6`快捷键让`ET`去编译

![](images/Pasted%20image%2020250824122121.png)

## 🌲 本地加载/静态加载

### 🌸 静态加载

与`动态加载`相反, 我们看`本地加载`也叫`静态加载`这个名字是我起的 - -

```cs
else
{
    // 如果不是动态加载就在当前领域内加载, gpt说是在内存中加载
    Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
    foreach (Assembly ass in assemblies)
    {
        string name = ass.GetName().Name;
        if (name == "Unity.Model")
        {
            this.modelAssembly = ass;
        }
        else if (name == "Unity.ModelView")
        {
            this.modelViewAssembly = ass;
        }

        if (this.modelAssembly != null && this.modelViewAssembly != null)
        {
            break;
        }
    }
}
```

我们在`Glocal Config`中把`dll`勾掉

![](images/Pasted%20image%2020250824122502.png)

然后再把`Code`文件夹的`dll`删掉

发现游戏也能运行, 那就证实了, 它确实是使用了`Library`下面的`ScriptAssemblies`的`dll`加载的

![](images/Pasted%20image%2020250824122543.png)

所以我们可以看到他不仅支持`运行时动态加载`, 也支持常规的编译模式`静态加载`, 就是游戏不支持热更新的话, 默认就在运行时或打包时静态加载已经生成的`dll`

### 🌸 混合`Unity`原生加载

我们发现了`ET`的一个特点, 就是它没有编译成`Assembly-CSharp.dll`, 我们是否可以让它编译呢

![](images/Pasted%20image%2020250824171616.png)

我们新建一个`MyScripts`文件夹, 然后创建一个脚本, 我们用`vs`打开, 发现确实帮我们创建了一个程序集

![](images/Pasted%20image%2020250824171928.png)

然后可以看到目录中生成了我们想要的

![](images/Pasted%20image%2020250824171954.png)

# 🍎 基础知识

## 🌲 IL2CPP

### 🌸 组成

首先要说的是`IL2CPP = 编译工具 + C++ runtime`

其中编译工具就是把`IL`编译成`C++`代码, `runtime`是用于支持`C#`的高级特性而实现的运行环境, 也叫做`IL2CPP VM`, 比如里面实现了C#中的`GC`垃圾回收

### 🌸 为什么使用IL2CPP

我们都知道`Unity`默认使用`Mono`平台作为运行时环境, 它是`C#`运行时的开源版本, 当我们在`Unity Editor`中运行项目的时候就是使用的这个环境, 在游戏打包的时候我们可以选择打包成`Mono`或者`IL2CPP`

有些环境无法使用`Mono`, 如下面的, 就必须打包成`IL2CPP`

```
✅（1）iOS 平台
Apple 的安全策略禁止在运行时生成或修改可执行代码
JIT（即时编译）属于运行时生成机器码 → 不允许
所以 iOS 下必须用 IL2CPP 生成 AOT 原生二进制

✅（2）主机平台（PlayStation / Switch / Xbox）
也要求运行时不生成动态代码
安全性、性能和认证要求，需要 AOT 编译
```

所以`Unity`才开发了可以让游戏在原生环境下运行的方法

- `iOS`编译流程`C#` -> `IL字节码` -> `经过IL2CPP` -> `C++代码` -> 再利用`Xcode`编译成`Apk`
- `Android`编译流程`C#` -> `IL字节码` -> `经过IL2CPP` -> `C++代码` -> 再利用`Android Studio`+`NDK`编译成`App`

### 🌸 热更新

但是`AOT`本身很难支持热更新, 所以需要使用最新的热更新技术`HybridCLR + AOT 元数据源`才能实现热更反射




